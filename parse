#!/usr/bin/env perl

# Noah Smith
# 3/2/2008, under the name cfgparse.pl, in cgw repository
# Modified by Alexandra DeLucia and Jason Eisner, 9/3/2020

# This script implements a probabilistic CKY parser.  It does the following:
#
# - loads a probabilistic CFG with root symbol ROOT
#   from a file that has one context-free rule per line, in the format
#        prob X Y ... Z      # representing the rule X -> Y ... Z
#   (the '#' symbol says that the rest of the line is a comment to be ignored)
#
# - renormalizes the probabilities so rules with the same left-hand
#   nonterminal sum to one
#
# - internally makes sure all rules are at most binary, transforming as needed
#
# - runs the CKY Viterbi algorithm on sentences read into STDIN
#   (one sentence per line, with whitespace separating words).
#   The input sentence may also include nonterminals as if they were words.
#
# - This version of CKY has been extended to handle unary rules, but
#   will not pursue cycles.  It does not handle epsilon rules (rules
#   with empty right-hand sides).
#
# - the CKY inside algorithm is run alongside the CKY Viterbi algorithm
#
# - for each sentence, writes out the probability of the best derivation,
#   the probability of the sentence, the probability of the best derivation
#   given the sentence, and the parse


use IO::Handle;
STDOUT->autoflush();   # ensure that output reaches the user immediately

use Getopt::Std;
$Getopt::Std::STANDARD_HELP_VERSION = 1;
getopts('s:o:cPghv') || die;

if ($opt_h) {
  print <<'EOM';
Usage:  parse [options] [grammar_files...]

Sentences (one per line, whitespace separating words) are expected on stdin.
Parse trees will go to stdout (one per line).
Extra info as requested will go to stdout as comment lines starting with #.

The weighted rules of a probabilistic CFG are read from the grammar files.

Options:
  -s symbol   seek a parse tree with this symbol at the top (default ROOT)
  -o oov      convert unknown input words to the specified oov symbol
  -c          print number of grammatical parses
  -P          print probability information
  -g          ignored (allowed for compatibility with a different version)
  -v          verbose output
  -h          print this help message
EOM
  exit 0;
}
if (@ARGV==0) {
  print "No grammar files specified.\n";
  print "Use the -h option to get usage help.\n";
  exit 0;
}

# Process options.
$ROOT_symbol = defined $opt_s ? $opt_s : "ROOT";
$OOV = defined $opt_o;
$OOV_symbol = $opt_o if $OOV;
$COUNT = $opt_c;
$PROBS = $opt_P;
$VERBOSE = $opt_v;

print "Warning: -c isn't supported yet.\n" if $COUNT;

# Read grammar files.
while($grammar = shift) {
    open(G, "<$grammar");

    while(<G>) {
	s/\#.*//;   # remove comments
	#if(($lhs, $rhs, $p) = (m/^\s*(\S+)\s*\-\>\s*(\S.*)\s+(\S+)\s*$/)) { #old CFG format: LHS -> RHS1 RHS2 prob
	if(($p, $lhs, $rhs) = (m/^\s*(\S+)\s+(\S+)\s*(\S.*)\s*$/)) { #new CFG format: prob LHS RHS1 RHS2

	    die "invalid probability $p on line $. (must be positive)" if($p <= 0.0);

	    @r = split /\s+/, $rhs;
	    foreach $s (@r) { $Symbol{$s} = 1;}
	    $Symbol{$lhs} = 1;
	    if(scalar(@r) == 1) {
		$Unary{$r[0]}{$lhs} += $p;
		$Tot{$lhs} += $p;
	    }
	    elsif(scalar(@r) == 2) {
		$Binary{$r[0]}{$r[1]}{$lhs} += $p;
		$Tot{$lhs} += $p;
	    }
	    elsif(scalar(@r) > 2) {
		$x = $r[-2] . "#" . $r[-1];
		$y = $r[-2];
		$z = $r[-1];
		for($i = scalar(@r) - 3; $i >= 0; --$i) {
		    $Binary{$y}{$z}{$x} += 1.0;
		    $Tot{$x} += 1.0;
		    $z = $x;
		    $x = $r[$i] . "#" . $x;
		    $y = $r[$i];
		}
		$Binary{$y}{$z}{$lhs} += $p;
		$Tot{$lhs} += $p;
	    }
	    else {
		die "bad rule:  $_";
	    }
	}
    }
    close(G);
}

# Index rules.
foreach $y (keys %Binary) {
    foreach $x (keys %{$Binary{$y}}) {
	foreach $z (keys %{$Binary{$y}{$x}}) {
	    $Binary{$y}{$x}{$z} = log($Binary{$y}{$x}{$z}) - log($Tot{$z});
	    # print "$z -> $y $x $Binary{$y}{$x}{$z}\n";
	}
    }
}
foreach $y (keys %Unary) {
    foreach $x (keys %{$Unary{$y}}) {
	$Unary{$y}{$x} = log($Unary{$y}{$x}) - log($Tot{$x});
	# print "$x -> $y $Unary{$y}{$x}\n";
    }
}

# Parse sentences.
$logprob = 0;
$words = 0;
while(<>) {
    %C = ();
    %B = ();
    %I = ();
    s/^\s*//; s/\s*$//;
    @W = split /\s+/;
    $n = scalar(@W);
    $words += $n;
    for($i = 0; $i < $n; ++$i) {
        $w = $W[$i];
        unless (defined $Symbol{$w}) {
	  if ($OOV) {
	    $w = $OOV_symbol
	  } else {
	    print STDERR "warning: input word \"$w\" is not in the grammar (consider using -o)\n";
	  }
	}
	$C{$i}{$i + 1}{$w} = 0.0;
	$I{$i}{$i + 1}{$w} = 0.0;
    }
    for($l = 1; $l <= $n; ++$l) {

	for($i = 0; $i <= $n - $l; ++$i) {
	    $k = $i + $l;
	    for($j = $i + 1; $j < $k; ++$j) {
		foreach $Y (keys %{$C{$i}{$j}}) {
		    $q = $C{$i}{$j}{$Y};
		    $qI = $I{$i}{$j}{$Y};
		    foreach $Z (keys %{$C{$j}{$k}}) {
			$r = $C{$j}{$k}{$Z};
			$rI = $I{$j}{$k}{$Z};
			foreach $X (keys %{$Binary{$Y}{$Z}}) {
			    $p = $Binary{$Y}{$Z}{$X} + $q + $r;
			    $pI = $Binary{$Y}{$Z}{$X} + $qI + $rI;
			    if(!(defined $C{$i}{$k}{$X}) or $p > $C{$i}{$k}{$X}) {
				$C{$i}{$k}{$X} = $p;
				$B{$i}{$k}{$X} = "$Y\t$Z\t$j";
				print "$i $k $X $p\n" if $VERBOSE;
			    }
			    $I{$i}{$k}{$X} = logadd($I{$i}{$k}{$X}, $pI);
			    print "$i $k $X ", $I{$i}{$k}{$X}, " (INSIDE)\n" if $VERBOSE;
			}
		    }
		}
	    }
            # Handle unary rule cycles.  (It's inefficient to repeat this for
	    # every span ($i,$k) as we do here; almost all of the work is
	    # position-independent and should be memoized.)
	    do {
	        %E = ();
		$changes = 0;
		foreach $Y (keys %{$I{$i}{$k}}) {
		    $q = $C{$i}{$k}{$Y};
		    $qI = $I{$i}{$k}{$Y};
		    $E{$Y} = logadd($E{$Y},$qI); delete $I{$i}{$k}{$Y};  # move the mass $qI that we're about to propagate from $I to $E so we don't propagate it again
		    foreach $X (keys %{$Unary{$Y}}) {
			$p = $Unary{$Y}{$X} + $q;
			$pI = $Unary{$Y}{$X} + $qI;
			if(!defined $C{$i}{$k}{$X} or $p > $C{$i}{$k}{$X}) {
			    $C{$i}{$k}{$X} = $p;
			    $B{$i}{$k}{$X} = $Y;
			    ++$changes;
			    print "$i $k $X $p  (u)\n" if $VERBOSE;
			}
			$I{$i}{$k}{$X} = logadd($I{$i}{$k}{$X}, $pI);
			print "$i $k $X ", $I{$i}{$k}{$X}, " (INSIDE; u)\n" if $VERBOSE;
		    }
		}
	    } while($changes > 0);
	    foreach $Y (keys %E) {
	        $I{$i}{$k}{$Y} = logadd($I{$i}{$k}{$Y}, $E{$Y});
	    }
	}
    }
    if(defined $C{0}{$n}{$ROOT_symbol}) {
	print backtrace(0, $n, $ROOT_symbol, 0), "\n";
    } else {
        print "failure\n";
        $C{0}{$n}{$ROOT_symbol} = nan;
	$I{0}{$n}{$ROOT_symbol} = -inf;
    }
    if($PROBS) {
        printf("# P(best_parse) = %3.3e\n# P(sentence) = %3.3e\n# P(best_parse | sentence) = %3.3f\n",
 		exp($C{0}{$n}{$ROOT_symbol}),  # different order than in the old Dyna parse program, but probably better
		exp($I{0}{$n}{$ROOT_symbol}),
		exp($C{0}{$n}{$ROOT_symbol} - $I{0}{$n}{$ROOT_symbol}));
        $logprob += $I{0}{$n}{$ROOT_symbol};
    }
}

if ($PROBS) {
  printf("# cross-entropy = %.3f bits = -(%.3f log-prob. / %d words)\n",
	      -$logprob/log(2)/$words, $logprob/log(2), $words);
}

sub backtrace {
    my $i = shift;
    my $k = shift;
    my $X = shift;
    my $indent = shift;
    my $ret = "";
    # print "bt($i, $k, $X)\n";
    my @l;
    $ret .= " ($X" unless($X =~ m/#/);
    if($X eq $W[$i] or $X eq $OOV_symbol) {
	return " " . $W[$i];
    }
    else {
	die "backtrace error ($i, $k, $X)" unless(defined $B{$i}{$k}{$X});
	@l = split /\t/, $B{$i}{$k}{$X};
	if(scalar(@l) == 1) {
	    $ret .= backtrace($i, $k, $l[0], $indent + 2);
	}
	else {
	    $ret .= backtrace($i, $l[2], $l[0], $indent + 2);
	    $ret .= backtrace($l[2], $k, $l[1], $indent + 2);
	}
    }
    $ret .= ")" unless($X =~ m/#/);
    return $ret;
}

sub logadd {
    my $lx = shift;
    my $ly = shift;
    if(!defined $lx || $lx eq '-inf') { return $ly; }
    if(!defined $ly || $ly eq '-inf') { return $lx; }
    my $d = $lx - $ly;
    if($d >= 0.0) {
	return $lx if($d > 745);
	return $lx + log(1.0 + exp(-$d));
    }
    else {
	return $ly if($d < -745);
	return $ly + log(1.0 + exp($d));
    }
}
